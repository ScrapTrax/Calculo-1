<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Derivadas usando límite del cociente de diferencias al cuadrado</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f2f5;
  }
  h1 {
    color: #2c3e50;
  }
  label {
    font-weight: bold;
  }
  input, button {
    font-size: 1rem;
    padding: 8px;
    margin: 5px 0 15px 0;
    width: 100%;
    max-width: 400px;
  }
  #steps {
    background: #fff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 0 7px rgba(0,0,0,0.1);
    margin-bottom: 30px;
    white-space: pre-wrap;
    font-family: monospace;
  }
  #graph {
    max-width: 800px;
    margin: auto;
  }
  .result {
    font-size: 1.1rem;
    margin-bottom: 15px;
    color: #34495e;
  }
  footer {
    margin-top: 40px;
    font-size: 0.85rem;
    color: #7f8c8d;
    text-align: center;
  }
</style>
<!-- Importar math.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
<!-- Importar Plotly.js -->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
  <h1>Derivada usando el límite del cociente de diferencias al cuadrado</h1>

  <label for="func">Ingrese función en x (ejemplo: x^2 + 3*x + 1, sin(x), ln(x)):</label>
  <input type="text" id="func" value="x^2 + 3*x + 1" />

  <label for="x0">Punto donde calcular derivada (x₀):</label>
  <input type="number" id="x0" value="2" step="any" />

  <button onclick="calcularDerivada()">Calcular derivada</button>

  <div class="result" id="resultado"></div>

  <h2>Explicación paso a paso del método largo (cociente de diferencias al cuadrado)</h2>
  <div id="steps"></div>

  <h2>Gráfica de la función y su derivada</h2>
  <div id="graph"></div>

<script>
  // Función para limpiar la función y adaptarla para math.js
  function parseFunction(fstr) {
    // Reemplazamos potencias "^" por "**"
    return fstr.replace(/\^/g, '**');
  }

  // Método límite del cociente de diferencias al cuadrado (derivada en x0)
  // f'(x0) = lim h->0 [f(x0+h) - f(x0 - h)] / (2h)
  // Lo implementaremos usando valores decrecientes de h para aproximar el límite
  // Explicamos paso a paso

  function calcularDerivada() {
    const fInput = document.getElementById('func').value.trim();
    const x0 = parseFloat(document.getElementById('x0').value);
    const resultadoDiv = document.getElementById('resultado');
    const stepsDiv = document.getElementById('steps');

    if (!fInput) {
      alert('Por favor ingrese una función válida.');
      return;
    }
    if (isNaN(x0)) {
      alert('Por favor ingrese un número válido para x₀.');
      return;
    }

    const fStr = parseFunction(fInput);

    // Compilar la función con math.js para evaluarla
    let fEval;
    try {
      fEval = math.compile(fStr);
      // Probar evaluación para evitar errores futuros
      fEval.evaluate({ x: x0 });
    } catch (e) {
      alert('Error en la función ingresada. Revisa la sintaxis.');
      return;
    }

    // Método largo: límite del cociente de diferencias centrado con h pequeños
    // Haremos varios pasos con h decrecientes y mostraremos los resultados
    const hs = [0.1, 0.01, 0.001, 0.0001, 0.00001];
    let pasosTexto = `Función: f(x) = ${fInput}\nPunto de derivación: x₀ = ${x0}\n\n`;

    pasosTexto += "Método del límite del cociente de diferencias al cuadrado:\n";
    pasosTexto += "f'(x₀) = lim h→0 [f(x₀ + h) - f(x₀ - h)] / (2h)\n\n";

    // Evaluar y mostrar cada paso
    let derivadasAprox = [];
    hs.forEach(h => {
      const f_x_plus_h = fEval.evaluate({ x: x0 + h });
      const f_x_minus_h = fEval.evaluate({ x: x0 - h });
      const derivada_h = (f_x_plus_h - f_x_minus_h) / (2 * h);

      pasosTexto += `Para h = ${h}:\n`;
      pasosTexto += `f(x₀ + h) = f(${x0} + ${h}) = ${f_x_plus_h.toFixed(8)}\n`;
      pasosTexto += `f(x₀ - h) = f(${x0} - ${h}) = ${f_x_minus_h.toFixed(8)}\n`;
      pasosTexto += `Derivada aproximada = (f(x₀ + h) - f(x₀ - h)) / (2h) = (${f_x_plus_h.toFixed(8)} - ${f_x_minus_h.toFixed(8)}) / (${2 * h}) = ${derivada_h.toFixed(8)}\n\n`;
      derivadasAprox.push(derivada_h);
    });

    // Derivada con math.js (método corto simbólico)
    let derivadaSimbolicaStr;
    let derivadaEval;
    try {
      const node = math.parse(fStr);
      const derivNode = math.derivative(node, 'x');
      derivadaSimbolicaStr = derivNode.toString();
      derivadaEval = derivNode.evaluate({ x: x0 });
    } catch (e) {
      derivadaSimbolicaStr = "Error al derivar simbólicamente";
      derivadaEval = NaN;
    }

    pasosTexto += `\nMétodo corto (derivada simbólica):\n`;
    pasosTexto += `f'(x) = ${derivadaSimbolicaStr}\n`;
    pasosTexto += `Evaluada en x₀ = ${x0}: f'(${x0}) = ${derivadaEval.toFixed(8)}\n`;

    // Mostrar resultados en pantalla
    resultadoDiv.innerHTML = `
      <b>Derivada aproximada por límite:</b> ${derivadasAprox[derivadasAprox.length - 1].toFixed(8)} <br/>
      <b>Derivada simbólica evaluada:</b> ${derivadaEval.toFixed(8)} <br/>
      <i>Nota: Ambas deberían ser muy similares para funciones suaves.</i>
    `;

    stepsDiv.textContent = pasosTexto;

    // Graficar función y derivada
    graficarFuncionYDerivada(fEval, derivadaEval, x0);
  }

  function graficarFuncionYDerivada(fEval, derivadaEval, x0) {
    const graphDiv = document.getElementById('graph');
    const xmin = x0 - 5;
    const xmax = x0 + 5;
    const numPoints = 200;
    const xs = [];
    const ys = [];
    const ysDeriv = [];

    for (let i = 0; i <= numPoints; i++) {
      const xVal = xmin + (i / numPoints) * (xmax - xmin);
      xs.push(xVal);
      try {
        ys.push(fEval.evaluate({ x: xVal }));
      } catch {
        ys.push(NaN);
      }
    }

    // Para la derivada, usaremos la fórmula simbólica si disponible.
    // Si no, usaremos el método largo con h muy pequeño para cada punto (pero es costoso).
    // Aquí simplificamos usando la derivada simbólica (faster y precisa)
    const derivNode = math.derivative(math.parse(fEval.toString()), 'x');
    for (let i = 0; i <= numPoints; i++) {
      const xVal = xs[i];
      try {
        ysDeriv.push(derivNode.evaluate({ x: xVal }));
      } catch {
        ysDeriv.push(NaN);
      }
    }

    const traceFunc = {
      x: xs,
      y: ys,
      mode: 'lines',
      name: 'f(x)',
      line: { color: 'blue' }
    };

    const traceDeriv = {
      x: xs,
      y: ysDeriv,
      mode: 'lines',
      name: "f'(x)",
      line: { color: 'red', dash: 'dot' }
    };

    // Punto x0 en la función y derivada
    const f_x0 = fEval.evaluate({ x: x0 });
    const fprime_x0 = derivNode.evaluate({ x: x0 });

    const tracePointFunc = {
      x: [x0],
      y: [f_x0],
      mode: 'markers',
      name: `f(${x0})`,
      marker: { color: 'blue', size: 10 }
    };

    const tracePointDeriv = {
      x: [x0],
      y: [fprime_x0],
      mode: 'markers',
      name: `f'(${x0})`,
      marker: { color: 'red', size: 10 }
    };

    const layout = {
      title: `Gráfica de f(x) y f'(x) alrededor de x = ${x0}`,
      xaxis: { title: 'x', zeroline: true },
      yaxis: { title: 'y', zeroline: true },
      showlegend: true,
      legend: { x: 0, y: 1 }
    };

    Plotly.newPlot(graphDiv, [traceFunc, traceDeriv, tracePointFunc, tracePointDeriv], layout, {responsive: true});
  }
</script>
</body>
</html>
